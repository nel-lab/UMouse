#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu May 27 12:02:56 2021

@author: andreagiovannucci
"""
import numpy as np
import pandas as pd
from behavelet import wavelet_transform
import umap
import os
#%%
class UMouse:
    def __init__(self, n_frequencies=25, f_sample=70, fmin=1, fmax=None, n_neighbors=15, n_components=2,**kwargs): 
        """
        
        Parameters
        ----------
        n_frequencies : int
            number of groups to divide the frequencies range into.
        fsample : int
            sampling frequency
        fmin : float
            minimum frequency of interest for the wavelet transformation.
        fmax : float
            maximum frequency of interest for the wavelet transformation.
        n_neighbors: int 
            see UMAP doc
        n_components: int
            see UMAP doc
        **kwargs : Misc
            keyword arguments for the UMAP class object initialization

        Returns
        -------
        None.

        """
        
        # default to Nyquist frequency
        if fmax is None:
            fmax = 0.5*f_sample
    
        self.n_frequencies=n_frequencies
        self.f_sample=f_sample
        self.fmin=fmin
        self.fmax=fmax       
        
        self.n_neighbors = n_neighbors
        self.n_components = n_components
        
        self.fit_data = None
        self.UMAP = umap.UMAP(n_neighbors=n_neighbors, n_components=n_components,**kwargs) 
        #   fr_per_sess : integer, optional
        # Number of frames to sample from each dataset. Only used if multiple datasets are indicated in fit_path. 
        # The default is 50000/(n datasets).  

    def fit(self, fr_per_sess=5000, df=None, columns=None, recompute_mwt=False,
                                        n_neighbors=None, n_components=None):
        """
        Loads frames to generate the embedding fit and performs the fit. Stores model as a class field. It assumes that auxiliary files are  created
        when computing the wavelet transform. If you want to recompute the transform 

        Parameters
        ----------
        df: dataframe,  a path or list of paths
            Df, Path or list of both for the behavioral data to be analyzed. The input format is compatible with DLC output

        columns: list of strings
            in case only a subset of the columns need to be used
        
        fr_per_sess: int
            number of frames to be used per session, if less than 0 all frames in all sessions are used
            
        recompute_mwt: Boolean
            if you want to recompute the MWT. You can also erase the  auxiliary xxx_mwt.npy files

        Returns
        -------
        Either a matrix, or a list of paths

        """
        if (type(df) is not list) or os.path.exists(df[0]):
            raise Exception('The input must be a list of paths to existing cvs files')
    
            
        for ddf in df:
             fit_data = []
             df_one_mouse = pd.load_cvs(ddf)
             target_path = ddf.split('.')[0]+'_mwt.npy'
             if os.path.exist(target_path):
                print('Found file:' + target_path + ", not recomputing wavelet transform")
                spect_data = np.load(target_path)
             else:
                spect_data = self._compute_mwt(df_one_mouse, self.n_frequencies, self.f_sample, self.fmin, self.fmax)
                np.save(spect_data, target_path) 
            
             if (fr_per_sess is None) or (fr_per_sess < 0):
                fit_data.append(spect_data)
             else:
                fit_data.append(spect_data[:-1][::len(spect_data)//fr_per_sess]) # select only fr_per_sess per mouse
        
        fit_data = np.array(fit_data)
                
        self.UMAP.fit(fit_data)
              
            
    def transform(self, df=None):
        """
        Uses the embedding model generated by self.fit to transform the datasets  indicated. 

        Parameters
        ----------
        transform_path : string or list, optional
            Path or list of paths for the spectrographic data to be analyzed. 
            The default is to use all the datsets in self.pathnames.

        Returns
        -------
        None.

        """
        if (type(df) is not list) or os.path.exists(df[0]):
            raise Exception('The input must be a list of paths to existing cvs files')
            
        for ddf in df:
            target_path = ddf.split('.')[0]+'_mwt.npy'
            target_path_csv = ddf.split('.')[0]+'_umap.csv'
            if os.path.exist(target_path):
               print('Found file:' + target_path + ", not recomputing wavelet transform")
               spect_data = np.load(target_path)
               #transform the new dataset
               this_embedding = self.UMAP.transform(spect_data)
               this_embedding = pd.Dataframe(this_embedding, columns=['dim_' + i for i in range(this_embedding.shape[1])])
               #save the new embedding
               ddf.join(this_embedding)
               ddf.to_csv(target_path_csv, this_embedding)
            else:
               raise Exception('File '+target_path+' not found,' + "Be sure you run the fit method first")
    
        
        

    def _compute_mwt(self, behavior_df, n_frequencies, f_sample, fmin, fmax):
        """
        Perform morlet wavelett transformation on the DLC data

        Parameters
        ----------
        behavior_df : pandas dataframe
            dataframe containing the DLC trajectory data.
        n_frequencies : int
            number of groups to divide the frequencies range into.
        fsample : int
            sampling frequency
        fmin : float
            minimum frequency of interest for the wavelet transformation.
        fmax : float
            maximum frequency of interest for the wavelet transformation.

        Returns
        -------
        freqs : ndarray, shape (n_freqs)
            The frequencies used for the wavelet transform
        power : ndarray, shape (n_samples)
            The total power for each row in X_new
        mwt_array : numpy array, shape (n_samples, n_features*n_freqs)
            Continuous wavelet transformed data

        """
        
        #perform transformation
        freqs, power, mwt_array = wavelet_transform(behavior_df.to_numpy(), 
                                                    n_freqs=n_frequencies, 
                                                    fsample=f_sample, 
                                                    fmin=fmin, 
                                                    fmax=fmax)
        
        return freqs, power, mwt_array
